package fr.durss.components.ui.form.numericstepper {	import fr.durss.components.events.NumericStepperEvent;	import fr.durss.components.ui.form.input.TextInput;	import fr.durss.skywar.skytimer.components.STGraphicButton;	import fr.durss.skywar.skytimer.data.SkinMetrics;	import fr.durss.skywar.skytimer.graphics.BackArrowsGraphics;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.FocusEvent;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.ui.Keyboard;	import flash.utils.Timer;	/**	 * Displays a numeric stepper.<p>	 * <p>	 * A numeric stepper is a simple textfield with two up and down buttons	 * to increase or decrease the number value of the textfield with maximum	 * and minimum limit values.	 * 	 * @author Fran√ßois	 */	public class NumericStepper extends Sprite {
		private var _upBt:STGraphicButton;		private var _downBt:STGraphicButton;		private var _backUpdown:BackArrowsGraphics;		private var _input:TextInput;		private var _timerIncrement:Timer;		private var _value:Number;		private var _currentIncrement:Number;		private var _min:Number;		private var _max:Number;		private var _increment:Number;		private var _disabledTics:int;						/* *********** *		 * CONSTRUCTOR *		 * *********** */		/**		 * Creates an instance of <code>NumericStepper</code> class.		 */		public function NumericStepper(min:Number, max:Number, increment:Number, value:Number) {			_increment = increment;			_max = max;			_min = min;			_value = value;			addEventListener(Event.ADDED_TO_STAGE, initialize);		}						/* ***************** *		 * GETTERS / SETTERS *		 * ***************** */		/**		 * Gets the stepper's value.		 */		public function get value():Number { return _value; }				/**		 * Sets the stepper's value.		 */		public function set value(v:Number):void {			if(v == 60) {				dispatchEvent(new NumericStepperEvent(NumericStepperEvent.MAX_EXCEEDED));			}else if(v == -1) {				dispatchEvent(new NumericStepperEvent(NumericStepperEvent.MIN_EXCEEDED));			}			v = (v<_min)? _max : v;			v = v % (_max+1);			_value = v;			_input.setText(v.toString(), "inputStepper");			dispatchEvent(new Event(Event.CHANGE));		}				/**		 * Sets the component's tab index		 */		override public function set tabIndex(value:int):void { _input.tabIndex = value; }						/* ****** *		 * PUBLIC *		 * ****** */						/* ******* *		 * PRIVATE *		 * ******* */		/**		 * Initialize the component		 */		private function initialize(e:Event):void {			removeEventListener(Event.ADDED_TO_STAGE, initialize);						_backUpdown	= addChild(new BackArrowsGraphics()) as BackArrowsGraphics;			_upBt		= addChild(new STGraphicButton(SkinMetrics.getInstance().skinUpBt)) as STGraphicButton;			_downBt		= addChild(new STGraphicButton(SkinMetrics.getInstance().skinDownBt)) as STGraphicButton;			_input		= addChild(new TextInput()) as TextInput;			_timerIncrement	= new Timer(20);			_timerIncrement.addEventListener(TimerEvent.TIMER, ticTimerHandler);						_input.y 		= 12;			_input.width	= 45;			_input.textfield.restrict = "0-9";			_backUpdown.x	= _input.width - 3;			_upBt.x			= _input.width + Math.round(SkinMetrics.getInstance().numericStepperButtonAddX);			_upBt.y			= 1;			_upBt.width		= 23;			_upBt.height	= 23;			_downBt.x		= _input.width + Math.round(SkinMetrics.getInstance().numericStepperButtonAddX);			_downBt.y		= 25;			_downBt.width	= 23;			_downBt.height	= 23;			value			= _value;//first rendering			_backUpdown.gotoAndStop(SkinMetrics.getInstance().frame);			_upBt.addEventListener(MouseEvent.MOUSE_DOWN,	mouseDownHandler);			_upBt.addEventListener(MouseEvent.MOUSE_UP,		mouseUpHandler);			_downBt.addEventListener(MouseEvent.MOUSE_DOWN,	mouseDownHandler);			_downBt.addEventListener(MouseEvent.MOUSE_UP,	mouseUpHandler);			_input.addEventListener(Event.CHANGE,			changeValueHandler);			stage.addEventListener(MouseEvent.MOUSE_UP,		mouseUpHandler);//releaseOutside			addEventListener(KeyboardEvent.KEY_DOWN,		keyDownHandler);			addEventListener(KeyboardEvent.KEY_UP,			keyUpHandler);			addEventListener(FocusEvent.FOCUS_IN,			focusInHandler);			addEventListener(FocusEvent.FOCUS_OUT,			focusOutHandler);			SkinMetrics.getInstance().addEventListener(Event.CHANGE, changeSkinHandler);		}
		/**		 * Called when a textfield's content change 		 */		private function changeValueHandler(e:Event):void {			var v:int = parseInt(_input.textfield.text);			v = isNaN(v)? 0 : v;			value = v;		}		/**		 * Called when component receives the focus		 */		private function focusInHandler(e:FocusEvent):void {			//funckin' patch to ignore focus on component's click. 			if(!hitTestPoint(stage.mouseX, stage.mouseY)) {//				_upBt.setOverState();//				_downBt.setOverState();			}		}		/**		 * Called when component looses the focus		 */		private function focusOutHandler(e:FocusEvent):void {//			_upBt.setOutState();//			_downBt.setOutState();		}		/**		 * Called when a key is pressed		 */		private function keyDownHandler(e:KeyboardEvent):void {			_disabledTics = 0;			if(stage.focus == this || _input.hasFocus()) {				if(e.keyCode == Keyboard.UP) {					_currentIncrement = 1;					ticTimerHandler();				}else if(e.keyCode == Keyboard.DOWN) {					_currentIncrement = -1;					ticTimerHandler();				}			}		}				/**		 * Called when a key is released		 */		private function keyUpHandler(e:KeyboardEvent):void			{ _timerIncrement.stop(); }		/**		 * Called when a timer's loop completes		 */		private function ticTimerHandler(e:TimerEvent = null):void	{			if(--_disabledTics > 0) return;			value += _currentIncrement;		}				/**		 * Called when an arrow is released		 */		private function mouseUpHandler(e:MouseEvent):void			{ _timerIncrement.stop(); }				/**		 * Called when an arrow is pressed		 */		private function mouseDownHandler(e:MouseEvent):void {			_currentIncrement	= (e.target == _upBt) ? _increment : -_increment;			_disabledTics		= 0;			ticTimerHandler();			_disabledTics		= 6;			_timerIncrement.start();		}		/**		 * Called when the skin is modified.		 */		private function changeSkinHandler(e:Event):void {			_upBt.background	= SkinMetrics.getInstance().skinUpBt;			_downBt.background	= SkinMetrics.getInstance().skinDownBt;			_backUpdown.gotoAndStop(SkinMetrics.getInstance().frame);			_upBt.x			= Math.round(_input.width + SkinMetrics.getInstance().numericStepperButtonAddX);			_downBt.x		= Math.round(_input.width + SkinMetrics.getInstance().numericStepperButtonAddX);		}	}}