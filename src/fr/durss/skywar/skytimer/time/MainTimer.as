package fr.durss.skywar.skytimer.time {	import fr.durss.skywar.skytimer.data.SharedObjectManager;	import flash.events.EventDispatcher;	import flash.events.TimerEvent;	import flash.utils.Timer;	import flash.utils.getTimer;	/**	 * Manages a global clock for the <code>CustomTimer</code> instances.<p>	 * <p>	 * This global clock can have two different operation modes :<p>	 * <p>	 * 1 - VIRTUAL CLOCK<p>	 * The first time the application is launched, the application's time is 0.	 * Then, the application updates this value and stores it continuously in	 * SharedObjects. Like that, the clock isn't dependant to the computer's clock.	 * The problem is that when the application is closed, the local clock	 * doesn't continues. And so, it's as if the clock is paused.<p>	 * <p>	 * 2 - REAL CLOCK<p>	 * The real clock mode uses the computer's clock to compute the time.<p>	 * With this kind of clock, the timers continue while the application is	 * closed. But, as it's computer's time based, if the computer's clock is	 * modified by the user, the timers compute will be wrong.	 * 	 * @author Fran√ßois	 */	public class MainTimer extends EventDispatcher {		private var _timer:Timer;		private var _localTime:Number;		private var _startTime:Number;				private static var _instance:MainTimer;						/* *********** *		 * CONSTRUCTOR *		 * *********** */		public function MainTimer(enforcer:singletonEnforcer) {			if (enforcer == null) {				throw new Error("Error: Instantiation failed: Use MainTimer.getInstance() instead of new.");			}else{				initialize();			}		}						/* ***************** *		 * GETTERS / SETTERS *		 * ***************** */		public static function getInstance():MainTimer {			if (_instance == null) {				_instance = new MainTimer(new singletonEnforcer());			}			return _instance;		}		/* ****** *		 * PUBLIC *		 * ****** */		/**		 * Gets the current time of the clock.		 */		public function getTime():Number {			if(SharedObjectManager.getInstance().internalClock) {				return _localTime;			}else{				return new Date().getTime();			}		}				/**		 * Sets the current time of the clock.<p>		 * <p>		 * Usefull only if using internal clock.<p>		 * This method is called only when loading an external data file.		 */		public function setTime(value:Number):void { _localTime = value; }								/* ******* *		 * PRIVATE *		 * ******* */		/**		 * inializes the class		 */		private function initialize():void {			if(SharedObjectManager.getInstance().time == 0) {				_startTime	= 0;				SharedObjectManager.getInstance().time = _startTime;			}else{				_startTime	= SharedObjectManager.getInstance().time;			}			_timer	= new Timer(500);			_timer.addEventListener(TimerEvent.TIMER, ticTimerHandler);			_timer.start();			ticTimerHandler();//Forces first clock tic		}		/**		 * Called when the timer 		 */		private function ticTimerHandler(e:TimerEvent = null):void {			_localTime = _startTime + getTimer();			SharedObjectManager.getInstance().time = _localTime;			dispatchEvent(new TimerEvent(TimerEvent.TIMER));		}	}}internal class singletonEnforcer { }