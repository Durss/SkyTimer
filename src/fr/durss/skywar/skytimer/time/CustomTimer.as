package fr.durss.skywar.skytimer.time {	import fr.durss.skywar.skytimer.events.CustomTimerEvent;	import flash.events.EventDispatcher;	import flash.events.TimerEvent;	/**	 * Used as clock for a <code>TimerItem</code>.<p>	 * <p>	 * Provides some public method to update, pause or seek the time.	 * 	 * @author Fran√ßois	 */	public class CustomTimer extends EventDispatcher {		private var _duration:Number;		private var _startTime:Number;		private var _totalPause:Number;		private var _mainTimer:MainTimer;		private var _paused:Boolean;		private var _running:Boolean;		private var _startPause:Number;		private var _initObject:Object;		private var _loop:Boolean;		private var _complete:Boolean;		private var _oldRepeatCount:int;						/* *********** *		 * CONSTRUCTOR *		 * *********** */		/**		 * Creates an instance of <code>CustomTimer</code> class.		 * 		 * @param duration		duration of the timer in milliseconds. Ignored if second parameter is specified		 * @param initObject	optional initialization object. @see <code>soObject</code> getter.		 */		public function CustomTimer(duration:Number, initObject:Object = null) {			_duration	= Math.max(1000, duration);			_initObject	= initObject;			initialize();		}						/* ***************** *		 * GETTERS / SETTERS *		 * ***************** */		/**		 * Gets the elapsed time.<p>		 * 		 * @return the alapsed time in milliseconds.		 */		public function get elapsedTime():Number	{			if(_complete) return _duration;			if(_loop) { 				return Math.min(_duration, (_mainTimer.getTime() - _startTime)%_duration - totalPause);			}else{				return Math.min(_duration, (_mainTimer.getTime() - _startTime) - totalPause);;			}		}		/**		 * Gets the resting time.<p>		 * 		 * @return the resting time in milliseconds.		 */		public function get restingTime():Number	{ return Math.max(0, _duration - elapsedTime); }				/**		 * Gets if the timer is paused or not.<p>		 * 		 * @return the pause state		 */		public function get paused():Boolean		{ return _paused; }				/**		 * Gets if the timers has completed.<p>		 * 		 * @return if the timer has compelted.		 */		public function get complete():Boolean		{ return _complete; }				/**		 * Sets if the timer should restart once it completes.<p>		 * 		 * @param value		the loop state		 */		public function set loop(value:Boolean):void{			if(!_loop && value) _oldRepeatCount = 0;			_loop = value;		}				/**		 * Gets if the timer should restart once it completes.<p>		 * 		 * @return the loop state		 */		public function get loop():Boolean			{ return _loop; }				/**		 * Gets the number of times the timer has looped.<p>		 * 		 * @return the number of loops		 */		public function get repeatCount():int		{ return Math.floor((_mainTimer.getTime() - _startTime - totalPause) / _duration); }				/**		 * Gets the timer's duration.<p>		 * 		 * @return the duration in milliseconds		 */		public function get duration():Number		{ return _duration; }		/**		 * Gets an anonymous object describing the current timer's state.<p>		 * <p>		 * Used to get an object that is stored in SharedObject.		 * 		 * @return an anonymous object reprensiting the timer		 */		public function get soObject():Object		{ return getObject(); }		/**		 * Gets the total paused time in function of the _paused state.<p>		 * 		 * @return the total pause time in milliseconds		 */		private function get totalPause():Number	{			if(_paused) {				return _totalPause + (_mainTimer.getTime() - _startPause);			} else {				return _totalPause;			}		}						/* ****** *		 * PUBLIC *		 * ****** */				/**		 * Starts the timer		 */		public function start():void {			if(_paused) {				_paused = false;				_totalPause += _mainTimer.getTime() - _startPause;				_startPause	= 0;			}			if(!_running || _complete) {				_running = true;				if(_startTime == 0 || isNaN(_startTime) || _complete) {					_complete	= false;					_startTime	= _mainTimer.getTime();					_totalPause	= 0;					_startPause	= 0;				}				_mainTimer.addEventListener(TimerEvent.TIMER, ticTimerHandler);			}			dispatchEvent(new CustomTimerEvent(CustomTimerEvent.START));			ticTimerHandler();		}		/**		 * Stops the timer		 */		public function stop():void {			if(_running) {				_running = false;				_mainTimer.removeEventListener(TimerEvent.TIMER, ticTimerHandler);			}		}		/**		 * Pauses the timer.		 */		public function pause():void {			if(_paused) return;			stop();			_paused		= true;			_startPause	= _mainTimer.getTime();		}		/**		 * Toggle the pause state of the timer.		 */		public function togglePause():void {			if(_running) {				pause();			} else {				start();			}		}		/**		 * Updates the timer's duration.<p>		 * <p>		 * Restarts the timer with the new duration has if it was a new timer.		 * 		 * @param duration	new timer's duration in milliseconds		 */		public function update(duration:Number):void {			_duration	= duration;			_startTime	= _mainTimer.getTime();			_totalPause	= 0;			_startPause	= 0;		}		/**		 * Seek the timer to go forward or backward.<p>		 * <p>		 * Just update the spent time of the timer.<p>		 * If the timer's duration is 60 seconds and this method is called with		 * 20 as parameter, the resting time of the timer will be 20.<p>		 * <p>		 * Now if the method is called with a value higher than the timer's duration,		 * in this case higher than 60s, the timer's duration will be updated to		 * the value.<p>		 * For exemple, the timer's duration is 60s, if this method is called		 * with 3600s as parameter, the new timer's duration will be 3600s.		 * 		 * @param value		value to seek to in milliseconds.		 */		public function seekTo(value:Number):void {			var isComplete:Boolean = _complete;			_totalPause	= 0;			_startTime	= _mainTimer.getTime();			_startPause	= _paused ? _startTime : 0;			if(_duration < value) {				_duration	= value;				_complete = false;			} else {				_startTime	-= _duration - value;				_complete	= value == 0;			}			if(isComplete && !_paused && value > 0) {				start();			}			dispatchEvent(new CustomTimerEvent(CustomTimerEvent.TIC_TIMER));		}				/**		 * makes the component garbage collectable.		 */		public function dispose():void {			_running = false;			_mainTimer.removeEventListener(TimerEvent.TIMER, ticTimerHandler);		}								/* ******* *		 * PRIVATE *		 * ******* */		/**		 * Initializes the timer		 */		private function initialize():void {			_mainTimer = MainTimer.getInstance();			if(_initObject == null) {				_paused		= false;				_totalPause	= 0;				_startPause	= 0;			} else {				_duration	= _initObject["duration"];				_startTime	= _initObject["start"];				_startPause	= _initObject["startPause"];				_paused		= _initObject["paused"];				_totalPause	= _initObject["totalPause"];				_loop		= getInitValue("loop", false);				if(!_paused) {					if(_loop) {						_complete = false;						_oldRepeatCount = repeatCount;						start();					} else {						start();					}				}else{					//_complete = isComplete;				}				if(_complete) {					_totalPause = 0;					_startPause = 0;				}			}		}		/**		 * Gets an anonymous object describing the current timer's state.<p>		 * <p>		 * Used to get an object that is stored in SharedObject.<p>		 * Alias of the <code>soObject</code> getter to have the object defintion		 * and the object parsing (on <code>initialize</code> method side by side.		 */		private function getObject():Object {			return {loop:_loop, paused:_paused, duration:_duration, start:_startTime, startPause:_startPause, totalPause:_totalPause};		}				/**		 * Gets a value on the initialization object.<p>		 * 		 * @return the asked value or <code>defaultValue</code> if it doesn't exists.		 */		private function getInitValue(id:String, defaultValue:*):* {			return (_initObject[id] == undefined)? defaultValue : _initObject[id];		}		/**		 * Called on <code>MainTimer</code>'s clock tic.		 */		private function ticTimerHandler(e:TimerEvent = null):void {			if(_complete || _paused) return;			if(isComplete) {				_complete	= true;				if(_loop) {					_oldRepeatCount = repeatCount;				} else {					stop();				}				if(_loop) _complete = false;				dispatchEvent(new CustomTimerEvent(CustomTimerEvent.COMPLETE));			} else {				dispatchEvent(new CustomTimerEvent(CustomTimerEvent.TIC_TIMER));			}		}				private function get isComplete():Boolean {			return elapsedTime >= _duration || (_loop && repeatCount > _oldRepeatCount);		}	}}