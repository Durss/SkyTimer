package fr.durss.skywar.skytimer.graphics.timers.window {	import fl.controls.ComboBox;	import fl.events.ListEvent;	import fr.durss.skywar.skytimer.data.CustomAssetsLists;	import fr.durss.skywar.skytimer.data.SkinMetrics;	import fr.durss.skywar.skytimer.graphics.timers.window.combo.ColorItemCellRenderer;	import fr.durss.skywar.skytimer.style.ComboStyle;	import flash.display.InteractiveObject;	import flash.display.Sprite;	import flash.events.Event;	import flash.media.Sound;	import flash.media.SoundChannel;	import flash.utils.getDefinitionByName;	/**	 * Displays two combo boxes that allows to select a sound and a color.<p>	 * 	 * @author Fran√ßois	 */	public class CustomAssetsSelector extends Sprite {		//Vars declaration		private var _comboSound:ComboBox;		private var _comboColor:ComboBox;		private var _sound:Sound;		private var _sc:SoundChannel;		private var _width:Number;						/* *********** *		 * CONSTRUCTOR *		 * *********** */		public function CustomAssetsSelector() { addEventListener(Event.ADDED_TO_STAGE, initialize); }						/* ***************** *		 * GETTERS / SETTERS *		 * ***************** */				/**		 * Sets the sound to play once timer completes.		 */		public function get sound():Sound {			if(_comboSound.selectedIndex == -1) {				return new (_comboSound.getItemAt(0)["data"])() as Sound;			}else{				return new _comboSound.selectedItem["data"]() as Sound;			}		}				/**		 * Sets the color of the timer.		 */		public function get color():Number {			if(_comboColor.selectedIndex == -1) {				return _comboColor.getItemAt(1)["data"] as Number;			}else{				return _comboColor.selectedItem["data"] as Number;			}		}				/**		 * Sets the width of the component without simply scaling it.		 */		override public function set width(value:Number):void { _width = value; computePositions(); }				/**		 * Gets the visual height of the component		 */		override public function get height():Number { return 24; 		}						/* ****** *		 * PUBLIC *		 * ****** */		/**		 * Sets the tab indexes of the comboboxes		 */		public function setTabIndexes(combo1:int, combo2:int):void {			_comboSound.tabIndex	= combo1;			_comboColor.tabIndex	= combo2;		}				/**		 * Called when an item is edited to load the good values in comboboxes.<p>		 * 		 * @param sound		a sound's reference or a class definition's name.		 * @param color		color value to pre-select		 */		public function preselect(sound:*, color:uint):void {			var i:int, len:int;			len = _comboColor.length;			for(i = 0; i<len; i++){				if(_comboColor.getItemAt(i)["data"] == color) {					_comboColor.selectedIndex = i;					break;				}			}						len = _comboSound.length;			if(sound is String) {				var classSound:Class = getDefinitionByName(sound) as Class;				sound = new classSound() as Sound;			}			for(i = 0; i<len; i++){				if(sound is _comboSound.getItemAt(i)["data"]) {					_comboSound.selectedIndex = i;					break;				}			}		}				/**		 * Resets the comboboxes selection index.		 */		public function reset():void {			_comboColor.selectedIndex = -1;			_comboSound.selectedIndex = -1;		}				/**		 * Closes the comboboxes.		 */		public function close():void {			_comboColor.close();			_comboSound.close();		}								/* ******* *		 * PRIVATE *		 * ******* */		/**		 * Initializes the elements		 */		private function initialize(e:Event):void {			removeEventListener(Event.ADDED_TO_STAGE, initialize);			var i:int;			_width		= 200;			_comboSound	= addChild(new ComboBox()) as ComboBox;			_comboColor	= addChild(new ComboBox()) as ComboBox;			_comboSound.prompt	= "Son";			_comboColor.prompt	= "Couleur";			for(i = 0;i < CustomAssetsLists.colors.length; i++) {				_comboColor.addItem({label:CustomAssetsLists.cLabels[i], data:CustomAssetsLists.colors[i]});			}			for(i = 0; i< CustomAssetsLists.sounds.length; i++) {				_comboSound.addItem({label:CustomAssetsLists.sLabel[i], data:CustomAssetsLists.sounds[i]});			}			_comboColor.focusManager.deactivate();			_comboSound.focusManager.deactivate();			ComboStyle.setStyles(_comboSound);			ComboStyle.setStyles(_comboColor, "comboboxPrompt", "comboboxItem", ColorItemCellRenderer);			_comboSound.addEventListener(Event.CHANGE,		changeComboHandler);			_comboSound.addEventListener(Event.CLOSE,		closeComboHandler);			_comboSound.dropdown.addEventListener(ListEvent.ITEM_ROLL_OVER,	overSoundItemHandler);			SkinMetrics.getInstance().addEventListener(Event.CHANGE,		changeSkinHandler);			computePositions();		}				/**		 * Called when the skin is modified.<p>		 */		private function changeSkinHandler(e:Event):void {			ComboStyle.setStyles(_comboColor);			ComboStyle.setStyles(_comboSound);		}		/**		 * Called when combobox's value changes.		 */		private function changeComboHandler(e:Event):void {			if(_sound != null) _sc.stop();			_sound = new _comboSound.selectedItem["data"]() as Sound;			_sc = _sound.play();		}		/**		 * Called when combobox is closed		 */		private function closeComboHandler(e:Event):void {			if(_sc != null) _sc.stop();			//Fuckin patch.			//If the focusManager of a combobox is deactivated and the user			//selects an entry, if the user then hit key down or up the component			//throws an error..			//This line solves this problem.			stage.focus = e.target as InteractiveObject;		}		/**		 * Called when a sound combobobx item is rolled over		 */		private function overSoundItemHandler(e:ListEvent):void {			if(_sound != null) _sc.stop();			_sound = new e.item["data"]() as Sound;			_sc = _sound.play();		}		/**		 * Resize and replace the elements		 */		private function computePositions():void {			_comboSound.width	= Math.round((_width - 15) * .5);			_comboColor.width	= _comboSound.width;			_comboSound.height	= 24;			_comboColor.height	= 24;			_comboSound.x		= 0;			_comboColor.x		= Math.round(_comboSound.x + _comboSound.width + 15);		}	}}