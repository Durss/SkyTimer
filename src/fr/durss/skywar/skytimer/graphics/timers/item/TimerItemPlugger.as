package fr.durss.skywar.skytimer.graphics.timers.item {	import fr.durss.skywar.skytimer.data.DependencyManager;	import fr.durss.skywar.skytimer.data.SkinMetrics;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Point;	/**	 * Displasy the plugs of a <code>TimerItem</code> instance.	 * 	 * @author  Francois	 */	public class TimerItemPlugger extends Sprite {				private var _input:Sprite;		private var _output:Sprite;		private var _timer:TimerItem;						/* *********** *		 * CONSTRUCTOR *		 * *********** */		/**		 * Creates an instance of <code>TimerItemPlugger</code>.		 */		public function TimerItemPlugger(timer:TimerItem) {			_timer = timer;			initialize();		}						/* ***************** *		 * GETTERS / SETTERS *		 * ***************** */		public function get inputPlugPos():Point {			//Pretty ugly targeting...i know...			return new Point( x + _input.x + _input["holeMc"].x + _input["holeMc"].width * .5							, y + _input.y + _input["holeMc"].y + _input["holeMc"].height * .5);		}				public function get outputPlugPos():Point {			//Pretty ugly targeting again...i know...again...			return new Point( x + _output.x + _output["holeMc"].x + _output["holeMc"].width * .5							, y + _output.y + _output["holeMc"].y + _output["holeMc"].height * .5);		}				/**		 * Gets the input plug reference (for tooltip display).		 */		public function get inputRef():Sprite { return _input; }				/**		 * Gets the output plug reference (for tooltip display).		 */		public function get outputRef():Sprite { return _output; }						/* ****** *		 * PUBLIC *		 * ****** */		/**		 * Makes the component garbage collectable.		 */		public function dispose():void {			DependencyManager.getInstance().disposeDependency(this);		}				/**		 * Gets the timer's reference associated to the plugger.		 */		public function get timerItem():TimerItem { return _timer; }						/* ******* *		 * PRIVATE *		 * ******* */		/**		 * Initialize the class.		 */		private function initialize():void {			changeSkinHandler();						SkinMetrics.getInstance().addEventListener(Event.CHANGE, changeSkinHandler);						computePositions();		}		/**		 * Resize and replace the elements.		 */		private function computePositions():void {			_input.x	= SkinMetrics.getInstance().plugButton1Pos.x;			_input.y	= SkinMetrics.getInstance().plugButton1Pos.y;			_output.x	= SkinMetrics.getInstance().plugButton2Pos.x;			_output.y	= SkinMetrics.getInstance().plugButton2Pos.y;		}				/**		 * Called when the skin is modified.		 */		private function changeSkinHandler(e:Event = null):void {			if(_input != null) {				removeChild(_input);				removeChild(_output);				_input.removeEventListener(MouseEvent.MOUSE_DOWN,	pressPlugHandler);				_output.removeEventListener(MouseEvent.MOUSE_DOWN,	pressPlugHandler);				_input.removeEventListener(MouseEvent.MOUSE_UP,		releasePlugHandler);				_output.removeEventListener(MouseEvent.MOUSE_UP,	releasePlugHandler);			}			_input	= addChild(SkinMetrics.getInstance().skinPlugButton) as Sprite;			_output	= addChild(SkinMetrics.getInstance().skinPlugButton) as Sprite;						_input.mouseChildren = false;			_output.mouseChildren = false;						_input.addEventListener(MouseEvent.MOUSE_DOWN,	pressPlugHandler);			_output.addEventListener(MouseEvent.MOUSE_DOWN,	pressPlugHandler);			_input.addEventListener(MouseEvent.MOUSE_UP,	releasePlugHandler);			_output.addEventListener(MouseEvent.MOUSE_UP,	releasePlugHandler);			computePositions();		}				/**		 * Called when a plug is pressed.		 */		private function pressPlugHandler(e:MouseEvent):void {			DependencyManager.getInstance().startPlug(this);		}				/**		 * Called when a plug is released.		 */		private function releasePlugHandler(e:MouseEvent):void {			DependencyManager.getInstance().stopPlug(this);		}	}}