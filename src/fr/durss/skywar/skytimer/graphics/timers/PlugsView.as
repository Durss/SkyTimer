package fr.durss.skywar.skytimer.graphics.timers {	import fr.durss.skywar.skytimer.data.Dependency;	import fr.durss.skywar.skytimer.data.DependencyManager;	import fr.durss.skywar.skytimer.errors.DependencyConflictError;	import fr.durss.skywar.skytimer.events.DependencyManagerEvent;	import fr.durss.skywar.skytimer.graphics.cursor.CursorManager;	import fr.durss.skywar.skytimer.graphics.timers.item.TimerItemPlugger;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.filters.BevelFilter;	import flash.geom.Point;	/**	 * Draws the cables between the plugged timers.	 * 	 * @author  Francois	 */	public class PlugsView extends Sprite {				private var _startTarget:TimerItemPlugger;								/* *********** *		 * CONSTRUCTOR *		 * *********** */		/**		 * Creates an instance of <code>PlugsView</code>.<br>		 */		public function PlugsView() {			addEventListener(Event.ADDED_TO_STAGE, initialize);		}						/* ***************** *		 * GETTERS / SETTERS *		 * ***************** */		/* ****** *		 * PUBLIC *		 * ****** */		/**		 * Updates the view render.		 */		public function update():void {			render();		}								/* ******* *		 * PRIVATE *		 * ******* */		/**		 * Initialize the class.<br>		 */		private function initialize(e:Event):void {			removeEventListener(Event.ADDED_TO_STAGE, initialize);						mouseEnabled = false;			filters = [new BevelFilter(1,135,0xffffff,1,0,1,2,2,1.4,3)];						DependencyManager.getInstance().addEventListener(DependencyManagerEvent.START_PLUG,	startPlugHandler);			DependencyManager.getInstance().addEventListener(DependencyManagerEvent.STOP_PLUG,	stopPlugHandler);			DependencyManager.getInstance().addEventListener(DependencyManagerEvent.UPDATE,		updatePlugHandler);			stage.addEventListener(MouseEvent.MOUSE_UP, stageReleaseHandler);						addEventListener(Event.ENTER_FRAME, enterFrameHandler);		}		/**		 * Called when the user start to plug an item.		 */		private function startPlugHandler(e:DependencyManagerEvent):void {			_startTarget = e.startTarget;		}		/**		 * Called when the user stops to plug an item.		 */		private function stopPlugHandler(e:DependencyManagerEvent):void {			if(e.stopTarget != null) {				try {					DependencyManager.getInstance().registerDependency(new Dependency(e.startTarget, e.stopTarget));				}catch(evt:DependencyConflictError)  {					CursorManager.getInstance().setCursor(CursorManager.WARNING, 500);				}				_startTarget = null;				render();			}		}				/**		 * Called when mouse ups over the stage.		 */		private function stageReleaseHandler(e:MouseEvent):void {			if(_startTarget != null) {				DependencyManager.getInstance().removeDependency(_startTarget, true, false);			}			_startTarget = null;			render();		}		/**		 * Called when the <code>DependencyManager</code> asks for an update of the view.		 */		private function updatePlugHandler(e:DependencyManagerEvent):void {			render();		}		/**		 * Called on enter frame handler.		 */		private function enterFrameHandler(e:Event):void {			if(_startTarget != null) {				var startPos:Point	= new Point(_startTarget.timerItem.x + _startTarget.inputPlugPos.x, _startTarget.timerItem.y + _startTarget.inputPlugPos.y);				var endPos:Point	= new Point(mouseX, mouseY);				render();				drawCable(startPos, endPos, 0xFFFFFF, .5);			}					}				/**		 * Draws a cable.		 */		private function drawCable(start:Point, end:Point, color:uint, alpha:Number = 1, thickness:int = 9):void {			graphics.lineStyle(thickness, color, alpha);			var d:int;			if(start.y > end.y) {				d = start.y - end.y;				graphics.moveTo(end.x, end.y);				graphics.curveTo(start.x + d*.08, end.y + d * .5, start.x, start.y);			}else{				d = end.y - start.y;				graphics.moveTo(start.x, start.y);				graphics.curveTo(end.x + d*.1, start.y + d * .5, end.x, end.y);			}		}				/**		 * Draws the cables.		 */		private function render():void {			var i:int, len:int, dependencies:Array, dependency:Dependency, input:TimerItemPlugger, output:TimerItemPlugger, start:Point, end:Point;			graphics.clear();			dependencies = DependencyManager.getInstance().dependencies;			len = dependencies.length;			for(i = 0; i < len; ++i) {				dependency	= dependencies[i] as Dependency;				input		= dependency.input;				output		= dependency.output;				start		= new Point(input.timerItem.x + input.inputPlugPos.x, input.timerItem.y + input.inputPlugPos.y);				end			= new Point(output.timerItem.x + output.outputPlugPos.x, output.timerItem.y + output.outputPlugPos.y);				drawCable(start, end, dependency.color, 1, 3);			}		}	}}