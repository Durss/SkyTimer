package fr.durss.skywar.skytimer.graphics.timers {	import fr.durss.components.ui.tooltip.SimpleToolTip;	import fr.durss.components.ui.tooltip.ToolTipAlign;	import fr.durss.skywar.skytimer.components.STGraphicButton;	import fr.durss.skywar.skytimer.data.DependencyManager;	import fr.durss.skywar.skytimer.data.SharedObjectManager;	import fr.durss.skywar.skytimer.data.SkinMetrics;	import fr.durss.skywar.skytimer.events.DependencyManagerEvent;	import fr.durss.skywar.skytimer.events.DragEvent;	import fr.durss.skywar.skytimer.events.SharedObjectManagerEvent;	import fr.durss.skywar.skytimer.events.TimerItemEvent;	import fr.durss.skywar.skytimer.events.TimerViewEvent;	import fr.durss.skywar.skytimer.events.WindowTimerEditionEvent;	import fr.durss.skywar.skytimer.graphics.AbstractView;	import fr.durss.skywar.skytimer.graphics.sessionselector.vo.Session;	import fr.durss.skywar.skytimer.graphics.timers.item.TimerItem;	import fr.durss.skywar.skytimer.graphics.timers.ressources.RessourcesManager;	import fr.durss.skywar.skytimer.graphics.timers.window.MainWindow;	import fr.durss.skywar.skytimer.time.MainTimer;	import fr.durss.skywar.skytimer.time.TimeFormater;	import gs.TweenLite;	import gs.easing.Sine;	import com.nurun.components.scroll.ScrollPane;	import com.nurun.components.scroll.scrollable.ScrollableDisplayObject;	import com.nurun.components.scroll.scroller.scrollbar.Scrollbar;	import com.nurun.components.text.CssTextField;	import flash.display.Bitmap;	import flash.display.Shape;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.geom.Point;	import flash.ui.Keyboard;	/**	 * Contains timers elements and make them scrollable.	 * 	 * @author François	 */	public class Timers extends AbstractView {
		private var _scrollbar:Scrollbar;		private var _scrollpane:ScrollPane;		private var _container:ScrollableDisplayObject;		private var _items:Array;		private var _howToUse:CssTextField;		private var _addTimerBt:STGraphicButton;		private var _window:MainWindow;		private var _lastTimerComplete:TimerItem;		private var _bitmapClone:Bitmap;		private var _dragLine:Shape;		private var _dragItem:TimerItem;		private var _offsetDrag:Point;		private var _ressources:RessourcesManager;		private var _tooltip:SimpleToolTip;		private var _orderASC:STGraphicButton;		private var _orderDESC:STGraphicButton;		private var _sessionLabel:CssTextField;		private var _plugs:PlugsView;
		
		
		/* *********** *		 * CONSTRUCTOR *		 * *********** */		public function Timers() { 
			addEventListener(Event.ADDED_TO_STAGE, initialize); 
		}
		
		
		/* ***************** *		 * GETTERS / SETTERS *		 * ***************** */		/**		 * replace by open / close methods.		 */		override public function set visible(value:Boolean):void {			super.visible = value;			if(!value) {				_window.close();			}		}		
		
		
		/* ****** *		 * PUBLIC *		 * ****** */		/**		 * Adds a timer to the list.		 * 		 * @param duration	timer's duration in milliseconds.		 * @param name		timer's name.		 * @param sessionID	session ID the timer should be associated with		 * 		 * @return	the timer's reference to act on it. For example set the sound and color values.		 */		public function addTimer(name:String, duration:Number, sessionID:String):TimerItem {			var timer:TimerItem = new TimerItem(name, duration);			timer.sessionID = sessionID;			_addTimer(timer);			computePositions(false);			saveTimers();						return timer;		}
		/**		 * Opens the creation window with a specific duration pre filled.		 */		public function createTimer(duration:Number):void {			_window.open(null, duration);			computePositions();		}
		/**		 * Saves the timers to SharedObject		 */		public function saveTimers():void {			SharedObjectManager.getInstance().saveTimers(_items);		}
		
		
		
		/* ******* *		 * PRIVATE *		 * ******* */		/**		 * Initialize the component.		 */		private function initialize(e:Event):void {			removeEventListener(Event.ADDED_TO_STAGE, initialize);			_container		= new ScrollableDisplayObject();			_scrollbar		= new Scrollbar(SkinMetrics.getInstance().skinScroll);			_scrollpane		= addChild(new ScrollPane(_container, _scrollbar)) as ScrollPane;			_plugs			= _container.content.addChild(new PlugsView()) as PlugsView;			_howToUse		= addChild(new CssTextField()) as CssTextField;			_addTimerBt		= addChild(new STGraphicButton(SkinMetrics.getInstance().skinAddTimerBt)) as STGraphicButton;			_orderASC		= addChild(new STGraphicButton(SkinMetrics.getInstance().skinOrderTimersButton)) as STGraphicButton;			_orderDESC		= addChild(new STGraphicButton(SkinMetrics.getInstance().skinOrderTimersButton)) as STGraphicButton;			_ressources		= addChild(new RessourcesManager()) as RessourcesManager;			_tooltip		= addChild(new SimpleToolTip()) as SimpleToolTip;			_bitmapClone	= addChild(new Bitmap()) as Bitmap;			_sessionLabel	= addChild(new CssTextField("sessionLabel")) as CssTextField;			_dragLine		= new Shape();						_sessionLabel.setText(SharedObjectManager.getInstance().getCurrentSession().name);						//TODO optimize, it takes about 130ms to initialize			_window			= addChild(new MainWindow(this)) as MainWindow;						_ressources.width			= 150;			_sessionLabel.width			= WIDTH;			_sessionLabel.wordWrap		= true;			_sessionLabel.background	= true;			 						_howToUse.setText("Pour ajouter un timer, cliquez sur l'<b>icône d'horloge</b> ci-dessous au milieu, ou pressez la touche <b>\"Echap\"</b>.", "howToUse");			_howToUse.width = WIDTH - 15;			_howToUse.wordWrap = true;						_bitmapClone.alpha	= .5;			_addTimerBt.width	= 20;			_addTimerBt.height	= 20;						_dragLine.visible = false;			_dragLine.graphics.clear();			_dragLine.graphics.beginFill(0xffffff, .5);			_dragLine.graphics.drawRect(0, 0, WIDTH, 6);			_dragLine.graphics.endFill();			_dragLine.graphics.lineStyle(2, 0xffffff, 1);			_dragLine.graphics.moveTo(3, 3);			_dragLine.graphics.lineTo(WIDTH - 3, 3);						_scrollpane.autoHideScrollers = false;						_sessionLabel.setText(SharedObjectManager.getInstance().getCurrentSession().name);			loadTimers();						stage.addEventListener(MouseEvent.MOUSE_UP,					releaseItemHandler);			stage.addEventListener(KeyboardEvent.KEY_UP,				keyUpHandler);			_addTimerBt.addEventListener(MouseEvent.CLICK,				addTimerHandler);			_orderASC.addEventListener(MouseEvent.CLICK,				clickOrderHandler);			_orderDESC.addEventListener(MouseEvent.CLICK,				clickOrderHandler);			_orderASC.addEventListener(MouseEvent.ROLL_OVER,			overOrderHandler);			_orderASC.addEventListener(MouseEvent.ROLL_OUT,				outOrderHandler);			_orderDESC.addEventListener(MouseEvent.ROLL_OVER,			overOrderHandler);			_orderDESC.addEventListener(MouseEvent.ROLL_OUT,			outOrderHandler);			_window.addEventListener(WindowTimerEditionEvent.EDIT_TIMER, editTimerCompleteHandler);			SkinMetrics.getInstance().addEventListener(Event.CHANGE,	changeSkinHandler);			DependencyManager.getInstance().addEventListener(DependencyManagerEvent.UPDATE,				dependencyChangeHandler);			SharedObjectManager.getInstance().addEventListener(SharedObjectManagerEvent.TIMERS_UPDATE,	changeDatasHandler);			SharedObjectManager.getInstance().addEventListener(SharedObjectManagerEvent.SESSION_CHANGE,	changeSessionHandler, false, 1);		}		/**		 * Do the real timer add by adding it to displays list, adding listeners, etc..		 */		private function _addTimer(item:TimerItem):void {			if(item.sessionID == SharedObjectManager.getInstance().currentSessionId) {				_container.content.addChild(item);				_container.content.addChild(_plugs);				_scrollpane.update();			}			item.addEventListener(TimerItemEvent.CLOSE,			closeItemHandler);			item.addEventListener(TimerItemEvent.EDIT,			editTimerHandler);			item.addEventListener(TimerItemEvent.PAUSE,			pauseItemHandler);			item.addEventListener(TimerItemEvent.LOOP,			loopItemHandler);			item.addEventListener(TimerItemEvent.COMPLETE,		completeItemHandler);			item.addEventListener(TimerItemEvent.CHANGE_SOUND,	changeSoundVolumeHandler);			item.addEventListener(TimerItemEvent.SHOW_TOOLTIP,	overItemHandler);			item.addEventListener(TimerItemEvent.HIDE_TOOLTIP,	outItemHandler);			item.addEventListener(TimerItemEvent.SHOW_PLUG_IN,	overItemHandler);			item.addEventListener(TimerItemEvent.SHOW_PLUG_OUT,	overItemHandler);			item.addEventListener(TimerItemEvent.HIDE_PLUG,		outItemHandler);			item.addEventListener(DragEvent.DRAG_START,			pressItemHandler);			item.addEventListener(DragEvent.DRAG_COMPLETE,		releaseItemHandler);			_items.push(item);		}
		/**		 * Removes a timer item.		 */		private function removeTimer(item:TimerItem):void {			if(_container.content.contains(item)) {				_container.content.removeChild(item);			}			TweenLite.killTweensOf(item);			item.removeEventListener(TimerItemEvent.CLOSE,			closeItemHandler);			item.removeEventListener(TimerItemEvent.EDIT,			editTimerHandler);			item.removeEventListener(TimerItemEvent.PAUSE,			pauseItemHandler);			item.removeEventListener(TimerItemEvent.LOOP,			loopItemHandler);			item.removeEventListener(TimerItemEvent.COMPLETE,		completeItemHandler);			item.removeEventListener(TimerItemEvent.CHANGE_SOUND,	changeSoundVolumeHandler);			item.removeEventListener(TimerItemEvent.SHOW_TOOLTIP,	overItemHandler);			item.removeEventListener(TimerItemEvent.HIDE_TOOLTIP,	outItemHandler);			item.removeEventListener(TimerItemEvent.SHOW_PLUG_IN,	overItemHandler);			item.removeEventListener(TimerItemEvent.SHOW_PLUG_OUT,	overItemHandler);			item.removeEventListener(TimerItemEvent.HIDE_PLUG,		outItemHandler);			item.removeEventListener(DragEvent.DRAG_START,			pressItemHandler);			item.removeEventListener(DragEvent.DRAG_COMPLETE,		releaseItemHandler);			item.dispose();			_plugs.update();		}		/**		 * Loads the timers stored on Shared objects.<p>		 */		private function loadTimers():void {			var i:int, timers:Array, len:int, timer:TimerItem;			_items	= [];			timers	= SharedObjectManager.getInstance().getTimers();			len		= timers.length;			for(i = 0;i < len; ++i) {				timer = timers[i] as TimerItem;				_addTimer(timer);			}			computePositions(false);		}
		/**		 * Called when a timer's file is loaded to shared objects.		 */		private function changeDatasHandler(e:SharedObjectManagerEvent):void {			var i:int, len:int;			len = _items.length;			for(i = 0;i < len; ++i) {				removeTimer(_items[i] as TimerItem);			}			_items = [];			loadTimers();		}				/**		 * Called when a new session is loaded.<br>		 */		private function changeSessionHandler(e:SharedObjectManagerEvent):void {			var session:Session = SharedObjectManager.getInstance().getCurrentSession();			_sessionLabel.setText(session.name);						var i:int, len:int, timer:TimerItem;			len = _items.length;			for(i = 0;i < len; ++i) {				timer = _items[i] as TimerItem;				if(timer.sessionID == session.id) {					_container.content.addChild(timer);				}else if(_container.content.contains(timer)) {					_container.content.removeChild(timer);				}			}						_container.content.addChild(_plugs);			_scrollbar.percent = 0;			_scrollpane.update(true);			computePositions(false);		}		/**		 * Called when the skin is modified		 */		private function changeSkinHandler(e:Event):void {			_scrollbar.setSkin(SkinMetrics.getInstance().skinScroll);			_orderASC.background	= SkinMetrics.getInstance().skinOrderTimersButton;			_orderDESC.background	= SkinMetrics.getInstance().skinOrderTimersButton;			_addTimerBt.background	= SkinMetrics.getInstance().skinAddTimerBt;			_sessionLabel.setText(_sessionLabel.text);//just to update the background color made by CSS styles			computePositions(false);		}
		/**		 * Called when add timer button is clicked		 */		protected function addTimerHandler(e:MouseEvent):void { 
			_window.open();
			computePositions();
		}				/**		 * Called if a dependency is added or removed.		 */		private function dependencyChangeHandler(e:DependencyManagerEvent):void { saveTimers(); }
		/**		 * Called when a timer is paused		 */		private function pauseItemHandler(e:TimerItemEvent):void { saveTimers(); }
		/**		 * Called when a timer loop mode is modified		 */		private function loopItemHandler(e:TimerItemEvent):void { saveTimers(); }
		/**		 * Called when edit button is clicked on a timer		 */		private function editTimerHandler(e:Event):void { _window.open(e.target as TimerItem); }
		/**		 * Called when an item edition completes		 */		private function editTimerCompleteHandler(e:WindowTimerEditionEvent):void {			saveTimers();			if(e.editedTimer != null) {				SharedObjectManager.getInstance().currentSessionId = e.editedTimer.sessionID;			}		}
		/**		 * Called when an item is closed.		 */		private function closeItemHandler(e:Event):void {			var item:TimerItem, index:int;			item = e.target as TimerItem;			index = getItemIndex(item);			_items.splice(index, 1);			_container.content.removeChild(item);			item.dispose();			saveTimers();			computePositions(false);			_plugs.update();		}
		/**		 * Called when a timer completes.		 */		private function completeItemHandler(e:Event):void {			try {				stage.nativeWindow.orderToFront();			}catch(event:Error) {				//Not AIR runtime			}			_lastTimerComplete = e.target as TimerItem;			//Loads the associated session			if(SharedObjectManager.getInstance().currentSessionId != _lastTimerComplete.sessionID) {				SharedObjectManager.getInstance().currentSessionId = _lastTimerComplete.sessionID;			}			//Scroll to the element			if(_container.content.contains(_lastTimerComplete)) {				_scrollbar.percent = _lastTimerComplete.y / (_container.height - _scrollpane.height);				_scrollpane.update(true);			}			dispatchEvent(new TimerViewEvent(TimerViewEvent.TIMER_COMPLETE, _lastTimerComplete));		}
		/**		 * Called when the volume of an item is modified.<p>		 */		private function changeSoundVolumeHandler(e:TimerItemEvent):void { saveTimers(); }
		/**		 * Replace the items		 */		private function computePositions(tween:Boolean = true):void {			var i:int, item:TimerItem, py:int, len:int, isItem:Boolean;			len = _items.length;			for(i = 0;i < len; ++i) {				item = _items[i] as TimerItem;				if(item != null && _container.content.contains(item)) {					TweenLite.killTweensOf(item);					isItem = true;					if(!tween){						item.y = py;					}else{						TweenLite.to(item, .5, {y:py, ease:Sine.easeInOut, onUpdate:_plugs.update, onComplete:_scrollpane.update});					}					py += Math.round(item.height);				}			}									if(SharedObjectManager.getInstance().getCurrentSession().id != SharedObjectManager.DEFAULT_SESSION.id) {				py = Math.round(_sessionLabel.height);				_scrollpane.height = HEIGHT - _ressources.height - 5 - py;			} else{				py = 0;				_scrollpane.height = HEIGHT - _ressources.height - 5;			}			_scrollpane.y = py;			_scrollpane.width = WIDTH;			_scrollpane.update();			_sessionLabel.visible= py > 0;						_howToUse.x = Math.round((WIDTH - 15 - _howToUse.width) * .5);			_howToUse.y = Math.round((HEIGHT - py - _ressources.height - _howToUse.height) * .5) + py;			_howToUse.visible = !isItem;						if(_window.alpha < .2) {				_window.x		= -3;				_window.y		= Math.round((HEIGHT - _window.height) * .5);			}			_ressources.x		= Math.round((WIDTH - _ressources.width) * .5);			_ressources.y		= HEIGHT - _ressources.height;			_addTimerBt.x		= Math.round((WIDTH - _addTimerBt.width) * .5);			_addTimerBt.y		= Math.round(_ressources.y + (_ressources.height - _addTimerBt.height) * .5);			_orderASC.width		= _orderASC.height = 13;			_orderDESC.width	= _orderDESC.height = 13;			_orderASC.x			= 10;			_orderASC.y			= Math.round(_ressources.y + (_ressources.height - _orderASC.height) * .5);			_orderDESC.x		= WIDTH - _orderDESC.width - 10;			_orderDESC.scaleY	= -1;			_orderDESC.y		= _orderASC.y + _orderDESC.height;			_plugs.update();		}										//__________________________________________________________ KEYBOARD EVENTS				/**		 * Called when a key is released.<br>		 */		private function keyUpHandler(e:KeyboardEvent):void {			//Dirty test "parent.visible" but don't want to break my ass...			//This test prevents from opening the window while the timers			//view isn't the one enabled.			if(e.keyCode == Keyboard.ESCAPE && parent.visible) {				if(_window.opened) {					_window.close();				}else{					_window.open();					computePositions();				}			}		}								//______________________________________________________________ MOUSE EVENTS		/**		 * Called when an order button is clicked.<p>		 */		private function clickOrderHandler(e:MouseEvent):void {			if(e.target == _orderASC) {				_items.sort(sortOnClock);			}else{				_items.sort(sortOnClockDesc);			}			computePositions(false);			saveTimers();		}				/**		 * Called when an order button is rolled over.<p>		 */		private function overOrderHandler(e:MouseEvent):void {			var txt:String, align:String;			if(e.target == _orderASC) {				txt = "Trier les timers<br/>par ordre croissant.";				align = ToolTipAlign.TOP_RIGHT;			}else{				txt = "Trier les timers<br/>par ordre décroissant.";				align = ToolTipAlign.TOP_LEFT;			}			_tooltip.open(txt, "toolTipContent", align);		}		/**		 * Called when an order button is rolled out.<p>		 */		private function outOrderHandler(e:MouseEvent):void { _tooltip.close(); }		/**		 * Called when an item is rolled over to display the ressources win estimations.<p>		 */		private function overItemHandler(e:TimerItemEvent):void {			var txt:String = "", item:TimerItem, cycles:int, hourEnd:Number = -1, cycleAtEnd:Number = -1;			if(e.type == TimerItemEvent.SHOW_TOOLTIP) {				item = e.target as TimerItem;				cycles = (item.clock.restingTime / SharedObjectManager.getInstance().cycleDuration);				txt += "• Gains :<br/>&nbsp;&nbsp;&nbsp;&nbsp;+" + cycles * SharedObjectManager.getInstance().materials + "<b>M</b>";				txt += "   +" + cycles * SharedObjectManager.getInstance().ethers + "<b>E</b><br/>";				if(!item.clock.complete) {					hourEnd		= new Date().getTime();					hourEnd		-= (new Date(0).timezoneOffset) * 60 * 1000;					cycleAtEnd	= MainTimer.getInstance().getTime();					var inc:int;					do {						hourEnd		+= item.clock.restingTime;						cycleAtEnd	+= item.clock.restingTime;						item		= item.getParentTimer();						if(item == null || ++inc > 10000)						break;					}while(item != null);					cycleAtEnd	-= SharedObjectManager.getInstance().cycleTimeReference;					cycleAtEnd	= cycleAtEnd % SharedObjectManager.getInstance().cycleDuration;				}				txt += "• Heure de fin :<br/>&nbsp;&nbsp;&nbsp;&nbsp;<b>" + ((hourEnd == -1)? "--" : TimeFormater.format(hourEnd,1,2,2,false)) + "</b><br/>";				txt += "• Cycle en fin de timer :<br/>&nbsp;&nbsp;&nbsp;&nbsp;<b>" + ((cycleAtEnd == -1) ? "--" : TimeFormater.format(cycleAtEnd)) + "</b> ";			}else if(e.type == TimerItemEvent.SHOW_PLUG_IN) {				txt = "IN";			}else if(e.type == TimerItemEvent.SHOW_PLUG_OUT) {				txt = "OUT";			}			_tooltip.open(txt, "toolTipContent", ToolTipAlign.BOTTOM_RIGHT);		}		/**		 * Called when an item is rolled out		 */		private function outItemHandler(e:TimerItemEvent):void { _tooltip.close(); }								//______________________________________________________________ DRAG EVENTS				/**		 * Called when an item starts to be dragged		 */		private function pressItemHandler(e:Event):void {			var item:TimerItem = e.target as TimerItem;			_bitmapClone.bitmapData = item.bitmapData;			_bitmapClone.y = item.y;			_bitmapClone.visible = true;			_dragLine.visible = true;			_dragItem = item;			_offsetDrag = new Point(_dragItem.mouseX, _dragItem.mouseY);			if(!hasEventListener(Event.ENTER_FRAME)) {				addEventListener(Event.ENTER_FRAME, dragHandler);			}			_container.content.addChild(_dragLine);			dragHandler();			mouseChildren = false;		}		/**		 * Called during drag to move the faded bitmap and draw the white line		 */		private function dragHandler(e:Event = null):void {			var py:Number, itemH:Number;			itemH = _dragItem.height;			if(_container.content.mouseY > _container.content.height) {				py = _container.content.height;			}else if(_container.content.mouseY < 0) {				py = 0;			} else {				py = _container.content.mouseY;			}						_bitmapClone.y	= Math.min(_scrollpane.height - itemH, Math.max(_scrollpane.y, mouseY - _offsetDrag.y));			_dragLine.y		= Math.round(py / itemH) * itemH - 1;			if(mouseY > _scrollpane.y + _scrollpane.height) {				_container.vPercent += (mouseY - (_scrollpane.height + _scrollpane.y)) * .001;				_scrollpane.update();			}else if(mouseY < _scrollpane.y) {				_container.vPercent -= (_scrollpane.y - mouseY) * .001;				_scrollpane.update();			}		}
		/**		 * Called when an item stops to be dragged.		 */		private function releaseItemHandler(e:Event):void {			if(_dragItem == null) return;			var i:int, len:int, indexes:Array, part1:Array, part2:Array, exIndex:int, newIndex:int, yIndex:int, newYIndex:int;						mouseChildren = true;			_container.content.removeChild(_dragLine);			removeEventListener(Event.ENTER_FRAME, dragHandler);						len = _items.length;			indexes = [];			for(i = 0; i < len; ++i) {				if(TimerItem(_items[i]).sessionID == SharedObjectManager.getInstance().currentSessionId) {					indexes.push(i);				}			}						exIndex		= getItemIndex(_dragItem);			yIndex		= Math.round(_dragItem.y / _dragItem.height);			newYIndex	= Math.round(_dragLine.y / _dragItem.height);			if(newYIndex > yIndex) newYIndex --;			newIndex	= (newYIndex < 0) ? 0 : (newYIndex > indexes.length - 1) ? indexes[indexes.length - 1] + 1  : indexes[newYIndex];						part1		= _items.slice(0, exIndex);			part2		= _items.slice(exIndex + 1);			_items		= part1.concat(part2);						part1		= _items.slice(0, newIndex);			part2		= _items.slice(newIndex);			_items		= part1.concat(_dragItem, part2);						_dragLine.visible	= false;			_bitmapClone.visible= false;			_container.content.addChild(_dragItem);			_container.content.addChild(_plugs);			_dragItem	= null;						computePositions();						saveTimers();		}
		/**		 * Gets the index of an item with its position		 */		private function getItemIndex(item:TimerItem):int { 
//			return Math.round(item.y / item.height);			var i:int, len:int;			len = _items.length;			for(i = 0; i < len; ++i) {				if(_items[i] == item) {					return i;				}			}			return -1;
		}
		
		
		
		//__________________________________________________________ ITEMS SORTING FUNCTIONS				/**		 * Sorts the items by their resting time.<p>		 */		private function sortOnClock(a:TimerItem, b:TimerItem):Number {			var clock1:Number = a.clock.restingTime;			var clock2:Number = b.clock.restingTime;			if(clock1 > clock2) {				return 1;			} else if(clock1 < clock2) {				return -1;			} else {				return 0;			}		}				/**		 * Sorts the items by their resting time.<p>		 */		private function sortOnClockDesc(a:TimerItem, b:TimerItem):Number {			var clock1:Number = a.clock.restingTime;			var clock2:Number = b.clock.restingTime;			if(clock1 > clock2) {				return -1;			} else if(clock1 < clock2) {				return 1;			} else {				return 0;			}		}	}}