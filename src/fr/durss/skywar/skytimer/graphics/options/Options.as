package fr.durss.skywar.skytimer.graphics.options {	import fl.controls.ComboBox;	import fr.durss.components.ui.tooltip.SimpleToolTip;	import fr.durss.components.ui.tooltip.ToolTipAlign;	import fr.durss.skywar.skytimer.components.STCheckbox;	import fr.durss.skywar.skytimer.data.SharedObjectManager;	import fr.durss.skywar.skytimer.data.SkinMetrics;	import fr.durss.skywar.skytimer.graphics.AbstractView;	import fr.durss.skywar.skytimer.style.ComboStyle;	import flash.desktop.NativeApplication;	import flash.display.InteractiveObject;	import flash.events.Event;	import flash.events.MouseEvent;	/**	 * Displays the options panel	 * 	 * @author François	 */	public class Options extends AbstractView {		private var _alwaysInFrontCb:STCheckbox;		private var _cutSound:STCheckbox;		private var _timeMode:STCheckbox;		private var _systray:STCheckbox;		private var _toolTip:SimpleToolTip;		private var _cycleDuration:CycleInput;		private var _skin:ComboBox;		private var _freeze:Boolean;		private var _cycleSynchroniser:CycleSync;		private var _startupExecute:STCheckbox;		private var _enableAlerts:STCheckbox;
		
		
		/* *********** *		 * CONSTRUCTOR *		 * *********** */		public function Options() { addEventListener(Event.ADDED_TO_STAGE, initialize); }						/* ***************** *		 * GETTERS / SETTERS *		 * ***************** */		/**		 * Setter overrided to check when the value changes.<br>		 * <br>		 * Enables and disbales some sub-components to save memory.		 */		override public function set visible(value:Boolean):void {			super.visible = value;			_cycleSynchroniser.enabled = value;			if(!value){				_skin.close();			}		}								/* ****** *		 * PUBLIC *		 * ****** */						/* ******* *		 * PRIVATE *		 * ******* */		/**		 * Initializes the template		 */		private function initialize(e:Event):void {			removeEventListener(Event.ADDED_TO_STAGE, initialize);			var i:int, elems:Array, dObj:InteractiveObject, py:int = 5;			_alwaysInFrontCb	= new STCheckbox("Conserver la fenêtre au 1er plan.") as STCheckbox;			_systray			= new STCheckbox("Réduire l'application dans la barre de notifications.");			_startupExecute		= new STCheckbox("Ouvrir au démarage du système.");			_enableAlerts		= new STCheckbox("Activer les alertes.");			_cutSound			= addChild(new STCheckbox("Couper le son.")) as STCheckbox;			_timeMode			= addChild(new STCheckbox("Utiliser une horloge virtuelle.")) as STCheckbox;			_skin				= addChild(new ComboBox()) as ComboBox;			_cycleDuration		= addChild(new CycleInput()) as CycleInput;			_cycleSynchroniser	= addChild(new CycleSync()) as CycleSync;						_cycleDuration.setTabIndexes(0, 1, 2);						_skin.addItem({label:"Skin Skatch", data:SkinMetrics.SKIN_SKATCH});			_skin.addItem({label:"Skin Dangren", data:SkinMetrics.SKIN_DANGREN});						elems = [_cutSound, _timeMode, _skin, _cycleDuration, _cycleSynchroniser];			/*FDT_IGNORE*/			CONFIG::Air			{			/*FDT_IGNORE*/				//Cleaner cette merde de doublon...				elems = [_alwaysInFrontCb, _cutSound, _systray, _timeMode, _startupExecute, _enableAlerts, _skin, _cycleDuration, _cycleSynchroniser];				addChild(_alwaysInFrontCb);				addChild(_systray);				addChild(_startupExecute);				addChild(_enableAlerts);			/*FDT_IGNORE*/			}			/*FDT_IGNORE*/						_toolTip	= addChild(new SimpleToolTip()) as SimpleToolTip;						graphics.lineStyle(1,0xffffff,.5);			for(i = 0; i < elems.length; i++) {				dObj		= elems[i];				dObj.x		= 5;				dObj.width	= WIDTH - 10;				dObj.y		= py;				py			+= Math.round(dObj.height + 8);				if(i < elems.length - 1) {					graphics.moveTo(5, py-5);					graphics.lineTo(WIDTH - 5, py-5);				}			}						_skin.addEventListener(Event.CHANGE,				changeItemHandler);			_cutSound.addEventListener(MouseEvent.CLICK,		changeItemHandler);			_timeMode.addEventListener(MouseEvent.CLICK,		changeItemHandler);			_systray.addEventListener(MouseEvent.CLICK,			changeItemHandler);			_startupExecute.addEventListener(MouseEvent.CLICK,	changeItemHandler);			_enableAlerts.addEventListener(MouseEvent.CLICK,	changeItemHandler);			_cycleDuration.addEventListener(Event.CHANGE,		changeItemHandler);			_cycleSynchroniser.addEventListener(Event.CHANGE,	changeItemHandler);			_timeMode.addEventListener(MouseEvent.ROLL_OVER,	overItemHandler);			_timeMode.addEventListener(MouseEvent.ROLL_OUT,		outItemHandler);			_alwaysInFrontCb.addEventListener(MouseEvent.CLICK,	changeItemHandler);			SkinMetrics.getInstance().addEventListener(Event.CHANGE, changeSkinHandler);			SharedObjectManager.getInstance().addEventListener(Event.CHANGE, setDatas);			_freeze = true;			setDatas();			_freeze = false;			ComboStyle.setStyles(_skin);		}		/**		 * Updates the components in function of the sharedObject		 */		private function setDatas(e:Event = null):void {			_alwaysInFrontCb.selected	= SharedObjectManager.getInstance().alwaysInFront;			_cutSound.selected			= SharedObjectManager.getInstance().soundMuted;			_timeMode.selected			= SharedObjectManager.getInstance().internalClock;			_systray.selected			= SharedObjectManager.getInstance().systrayClose;			_startupExecute.selected	= SharedObjectManager.getInstance().startupExecute;			_enableAlerts.selected		= SharedObjectManager.getInstance().enableAlerts;			_cycleDuration.timestamp	= SharedObjectManager.getInstance().cycleDuration;			_skin.selectedItem			= SharedObjectManager.getInstance().skin;			var i:int, len:int;			len = _skin.length;			for (i = 0; i < len; ++i) {				if(_skin.getItemAt(i)["data"] == SharedObjectManager.getInstance().skin) {					_skin.selectedIndex = i;					break;				}			}			SkinMetrics.getInstance().loadSkin(SharedObjectManager.getInstance().skin);			try {				stage.nativeWindow.alwaysInFront	= _alwaysInFrontCb.selected;			}catch(event:Error) {				//Not on AIR runtime			}		}				/**		 * Updates the SharedObject datas.		 */		private function changeItemHandler(e:Event = null):void {			if(_freeze) return;			SharedObjectManager.getInstance().alwaysInFront	= _alwaysInFrontCb.selected;			SharedObjectManager.getInstance().soundMuted	= _cutSound.selected;			SharedObjectManager.getInstance().internalClock	= _timeMode.selected;			SharedObjectManager.getInstance().systrayClose	= _systray.selected;			SharedObjectManager.getInstance().startupExecute= _startupExecute.selected;			SharedObjectManager.getInstance().enableAlerts	= _enableAlerts.selected;			SharedObjectManager.getInstance().cycleDuration = _cycleDuration.timestamp;			SkinMetrics.getInstance().loadSkin(_skin.selectedItem["data"]);			ComboStyle.setStyles(_skin);			try {				stage.nativeWindow.alwaysInFront	= _alwaysInFrontCb.selected;				NativeApplication.nativeApplication.startAtLogin = _startupExecute.selected;			}catch(event:Error) {				//Not on AIR runtime			}		}				/**		 * Called when an item is rolled over		 */		private function overItemHandler(e:MouseEvent):void {			var txt:String = "";			var align:String = ToolTipAlign.TOP_LEFT;			if(e.target == _timeMode) {				txt		= "Si cette option est activée, l'application n'utilisera pas l'horloge de votre ordinateur mais une horloge virtuelle. <br/><br/><b>Avantage :</b><br/>Ceci permet de ne pas avoir de décallage dans les timers si l'heure de votre ordinateur est modifiée.<br/><br/><b>Inconvéniant :</b><br/>Lorsque l'application est fermée les timers restent en pause.<br/><br/><b>Attention :</b><br/>Si cette option est modifiée alors que des timers sont existants, ceux-ci seront désynchronisés!";				align	= ToolTipAlign.BOTTOM_RIGHT;				_toolTip.width = 190;			}			if(txt.length > 0){				_toolTip.open(txt, "toolTipContent", align);			}		}		/**		 * Called when an item is rolled out		 */		private function outItemHandler(e:MouseEvent):void { _toolTip.close(); }				/**		 * Called when the skin is modified.		 */		private function changeSkinHandler(e:Event):void {			_alwaysInFrontCb.changeSkin();			_cutSound.changeSkin();			_timeMode.changeSkin();			_systray.changeSkin();			_startupExecute.changeSkin();			_enableAlerts.changeSkin();		}	}}