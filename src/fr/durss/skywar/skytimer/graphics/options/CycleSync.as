package fr.durss.skywar.skytimer.graphics.options {	import fr.durss.components.ui.tooltip.SimpleToolTip;	import fr.durss.components.ui.tooltip.ToolTipAlign;	import fr.durss.skywar.skytimer.components.SubmitButton;	import fr.durss.skywar.skytimer.data.SharedObjectManager;	import fr.durss.skywar.skytimer.data.SkinMetrics;	import fr.durss.skywar.skytimer.time.MainTimer;	import fr.durss.skywar.skytimer.time.TimeFormater;	import com.nurun.components.text.CssTextField;	import com.nurun.components.vo.Margin;	import flash.display.Shape;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.geom.Rectangle;	import flash.utils.Timer;	/**	 * Displays the cycle synchroniser bar.<br>	 * <br>	 * Fires an <code>Event.CHANGE</code> event when the value is modified.<br>	 * 	 * @author  Francois	 */	public class CycleSync extends Sprite {				private var _cursor:Sprite;		private var _label:CssTextField;		private var _width:Number		= 100;		private var _exPercent:Number	= .5;		private var _timeOffset:Number	= 0;		private var _toolTip:SimpleToolTip;		private var _pressed:Boolean;		private var _timer:Timer;		private var _syncBt:SubmitButton;		private var _line:Shape;						/* *********** *		 * CONSTRUCTOR *		 * *********** */		/**		 * Creates an instance of <code>CyclePosition</code>.<br>		 */		public function CycleSync() {			addEventListener(Event.ADDED_TO_STAGE, initialize);		}						/* ***************** *		 * GETTERS / SETTERS *		 * ***************** */		/**		 * Sets the component's width without simply scaling it.<br>		 */		override public function set width(value:Number):void { _width = value; computePositions(); }				/**		 * Gets the percent where the cursor is placed.<br>		 */		public function get percent():Number { return _cursor.x / (_line.width - _cursor.width); }				/**		 * sets the cycle timestamp offset.<br>		 */		public function set timeOffset(value:Number):void {			_timeOffset = value;			_exPercent = _timeOffset / SharedObjectManager.getInstance().cycleDuration;			computePositions();		}				/**		 * Defines if the cocmponent is enabled or not.<br>		 */		public function set enabled(value:Boolean):void {			if(value) {				_timer.start();			}else if(!value) {				_timer.stop();			}			ticTimerHandler();		}						/* ****** *		 * PUBLIC *		 * ****** */						/* ******* *		 * PRIVATE *		 * ******* */		/**		 * Initialize the class.<br>		 */		private function initialize(e:Event):void {			removeEventListener(Event.ADDED_TO_STAGE, initialize);						_line	= addChild(new Shape()) as Shape;			_label	= addChild(new CssTextField()) as CssTextField;			_label.setText("Temps restant avant le prochain cycle :", "windowLabel");			_toolTip = addChild(new SimpleToolTip()) as SimpleToolTip;			_syncBt = addChild(new SubmitButton("RESET")) as SubmitButton;			_timer	= new Timer(500);			_timer.addEventListener(TimerEvent.TIMER, ticTimerHandler);			_syncBt.contentMargin = new Margin(0, 0, 0, 0, 10, 6);						_syncBt.addEventListener(MouseEvent.CLICK, clickResetHandler);			SkinMetrics.getInstance().addEventListener(Event.CHANGE, changeSkinHandler);			stage.addEventListener(MouseEvent.MOUSE_UP, stageReleaseHandler);						changeSkinHandler();		}		/**		 * Resize and replace the elements.<br>		 */		private function computePositions():void {			var py:int = Math.round((_cursor.height - 4) * .5);						_cursor.y = py + _label.height;			_cursor.x = _exPercent * (_line.width - _cursor.width);						_line.y = py + _cursor.y;			_line.graphics.clear();			_line.graphics.beginFill(SkinMetrics.getInstance().cycleBarColor);			_line.graphics.drawRect(0, 0, _width - _syncBt.width - 10, 4);						_syncBt.height = 23;			_syncBt.x = _line.width + 10;			_syncBt.y = Math.round((_line.height - _syncBt.height) * .5 + _line.y);						ticTimerHandler();		}				/**		 * Called when reset button is clicked.		 */		private function clickResetHandler(e:MouseEvent):void {			_cursor.x = 0;			endMove();		}		/**		 * Called when the skin is modified.<br>		 */		private function changeSkinHandler(e:Event = null):void {			if(_cursor != null) {				removeChild(_cursor);				_cursor.removeEventListener(MouseEvent.MOUSE_OVER,		overArrowHandler);				_cursor.removeEventListener(MouseEvent.MOUSE_OUT,		outArrowHandler);				_cursor.removeEventListener(MouseEvent.MOUSE_DOWN,		pressArrowHandler);				_cursor.removeEventListener(MouseEvent.MOUSE_UP,		releaseArrowHandler);			}			_syncBt.changeSkin();			_cursor = addChild(SkinMetrics.getInstance().cycleArrow) as Sprite;			_cursor.buttonMode = true;			_cursor.addEventListener(MouseEvent.MOUSE_OVER,		overArrowHandler);			_cursor.addEventListener(MouseEvent.MOUSE_OUT,		outArrowHandler);			_cursor.addEventListener(MouseEvent.MOUSE_DOWN,		pressArrowHandler);			_cursor.addEventListener(MouseEvent.MOUSE_UP,		releaseArrowHandler);			addChild(_toolTip);			computePositions();		}						//__________________________________________________________ EVENTS HANDLERS				private function overArrowHandler(e:MouseEvent):void {			_toolTip.open("", "toolTipContent", ToolTipAlign.TOP_RIGHT);			ticTimerHandler();		}		private function outArrowHandler(e:MouseEvent):void {			if(!_pressed) {				_toolTip.close();			}		}				/**		 * Called when the arrow is pressed.<br>		 */		private function pressArrowHandler(e:MouseEvent):void {			var bounds:Rectangle = new Rectangle();			bounds.x = 0;			bounds.y = _cursor.y;			bounds.width = _line.width - _cursor.width;			bounds.height = 0;			_pressed = true;			_cursor.startDrag(false, bounds);			_toolTip.open("", "toolTipContent", ToolTipAlign.TOP_RIGHT);			ticTimerHandler();		}		/**		 * Called when the arrow is released.<br>		 */		private function releaseArrowHandler(e:MouseEvent):void {			e.stopPropagation();			endMove();			_pressed = false;		}				/**		 * Called when the mouse is released on the stage.<br>		 */		private function stageReleaseHandler(e:MouseEvent):void {			if(!_pressed) return;			endMove();			_pressed = false;			_toolTip.close();		}		/**		 * Stops listeners/drag and update the percent value.<br>		 */		private function endMove():void {			_cursor.stopDrag();			var cycleDuration:int = SharedObjectManager.getInstance().cycleDuration;			SharedObjectManager.getInstance().cycleTimeReference = MainTimer.getInstance().getTime() - (cycleDuration * percent);			if(_exPercent != percent) {				_exPercent = percent;				dispatchEvent(new Event(Event.CHANGE));			}		}				/**		 * Called on timer's tic to update the tooltip's content and the cursor positions.<br>		 */		private function ticTimerHandler(e:TimerEvent = null):void {			if(!_pressed) {				var cycleDuration:int = SharedObjectManager.getInstance().cycleDuration;				var cycle:int	= (MainTimer.getInstance().getTime() - SharedObjectManager.getInstance().cycleTimeReference) % cycleDuration;				_cursor.x		= (cycle / cycleDuration) * (_line.width - _cursor.width);			}			var time:String = TimeFormater.format(SharedObjectManager.getInstance().cycleDuration * (1-percent));			_toolTip.setContent(time);		}	}}