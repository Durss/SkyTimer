package fr.durss.skywar.skytimer.data {	import fr.durss.skywar.skytimer.errors.DependencyConflictError;	import fr.durss.skywar.skytimer.events.DependencyManagerEvent;	import fr.durss.skywar.skytimer.events.SharedObjectManagerEvent;	import fr.durss.skywar.skytimer.graphics.timers.item.TimerItemPlugger;	import flash.events.EventDispatcher;	import flash.utils.Dictionary;	/**	 * Manages the dependencies between timers.	 * 	 * @author @author Francois	 */	public class DependencyManager extends EventDispatcher {				private static var _instance:DependencyManager;		private var _startTarget:TimerItemPlugger;		private var _stopTarget:TimerItemPlugger;		private var _dependencies:Array;		private var _enabledDependencies:Array;		private var _outputs:Dictionary;		private var _lockDispatch:Boolean;						/* *********** *		 * CONSTRUCTOR *		 * *********** */		/**		 * Creates an instance of <code>DependencyManager</code>.<br>		 */		public function DependencyManager(enforcer:SingletonEnforcer) {			enforcer;		// Avoiding unused warning from FDT 3			initialize();		}						/* ***************** *		 * GETTERS / SETTERS *		 * ***************** */		/**		 * Singleton instance getter		 */		public static function getInstance():DependencyManager {			if(_instance == null)_instance = new  DependencyManager(new SingletonEnforcer());			return _instance;			}				/**		 * Gets the stop plug target.		 */		public function get stopTarget():TimerItemPlugger { return _stopTarget; }				/**		 * Gets the start plug target.		 */		public function get startTarget():TimerItemPlugger { return _startTarget; }				/**		 * Gets only the enabled dependencies.		 */		public function get dependencies():Array { return _enabledDependencies.concat(); }				/**		 * Gets all the dependencies.		 */		public function get allDependencies():Array { return _dependencies.concat(); }						/* ****** *		 * PUBLIC *		 * ****** */		/**		 * Function to call when starting to plug an item.<br>		 * <br>		 * The cable view will then know that a plug is starting and so it		 * will start to display a cable.		 */		public function startPlug(target:TimerItemPlugger):void {			_startTarget = target;			dispatchEvent(new DependencyManagerEvent(DependencyManagerEvent.START_PLUG, _startTarget, null));		}				/**		 * Function to call when stoping to plug an item.<br>		 * <br>		 * The cable view will then know that a plug is completed and so it		 * will display the cable.		 */		public function stopPlug(target:TimerItemPlugger):void {			_stopTarget = target;			if(_stopTarget == _startTarget) {				_stopTarget = _startTarget = null;			}			dispatchEvent(new DependencyManagerEvent(DependencyManagerEvent.STOP_PLUG, _startTarget, _stopTarget));		}				/**		 * Registers a dependency.		 * 		 * @param dependency	dependency to create.		 * @param fireChange	ugly flag to define if an UPDATE event should be fired or not		 * 		 * @throws DependencyConflictError		 */		public function registerDependency(dependency:Dependency, fireChange:Boolean = true):void {			var pointer:TimerItemPlugger, plugs:Array;			plugs	= [dependency.output];			pointer	= dependency.output;						//Check for cross dependencies			while(pointer != null && pointer != dependency.input) {				pointer = _outputs[pointer];				plugs.push(pointer);			}			if(pointer == dependency.input) {				throw new DependencyConflictError(plugs);				return;				//Toggle the following commented lines with the previous lines to enable cross dependencies//				_lockDispatch = true;//				removeDependency(pointer);//				_lockDispatch = false;			}						//Removes dependencies already existing			_lockDispatch = true;			removeDependency(dependency.input, true, false);			removeDependency(dependency.output, false, true);			_lockDispatch = false;						_outputs[dependency.input] = dependency.output;			_dependencies.push(dependency);			dependency.output.timerItem.setParentTimer(dependency.input.timerItem);						filterDependencies();						if(fireChange) {				dispatchEvent(new DependencyManagerEvent(DependencyManagerEvent.UPDATE));			}		}		/**		 * Removes a dependency.<br>		 * <br>		 * Called when a <code>TimerItem</code> is removed.<br>		 * <br>		 * Called too when creating a new dependency to remove the possible conflicts.<br>		 * <br>		 * It finally can be  called when the user clicks on an input, without		 * dragging the wire to an output, to remove a dependency.		 * 		 * @param target	target to remove the dependencies of.		 */		public function removeDependency(target:TimerItemPlugger, input:Boolean = true, output:Boolean = true):void {			var i:int, len:int, dependency:Dependency;			len = _dependencies.length;			for(i = 0; i < len; ++i) {				dependency = _dependencies[i] as Dependency;				if((input && dependency.input == target) || (output && dependency.output == target)) {					_dependencies.splice(i, 1);					dependency.output.timerItem.setParentTimer(null);					i--;					len --;				}			}			if(input) {				_outputs[target] = null;			}			filterDependencies();						if(!_lockDispatch) {				dispatchEvent(new DependencyManagerEvent(DependencyManagerEvent.UPDATE));			}		}				/**		 * Clears all the dependencies from a specifi target, without fireing UPDATE event.		 */		public function disposeDependency(target:TimerItemPlugger):void {			_lockDispatch = true;			removeDependency(target);			_lockDispatch = false;		}								/* ******* *		 * PRIVATE *		 * ******* */		/**		 * Initialize the class.<br>		 */		private function initialize():void {			_dependencies = [];			_outputs = new Dictionary();			SharedObjectManager.getInstance().addEventListener(SharedObjectManagerEvent.SESSION_CHANGE, changeSessionHandler);			filterDependencies();		}				/**		 * Called when the skin is modified.		 */		private function changeSessionHandler(e:SharedObjectManagerEvent):void {			filterDependencies();			dispatchEvent(new DependencyManagerEvent(DependencyManagerEvent.UPDATE));		}				/**		 * Filter the dependency in function of the current session ID.		 */		private function filterDependencies():void {			var i:int, len:int, dependency:Dependency, session:String;			session = SharedObjectManager.getInstance().currentSessionId;			len = _dependencies.length;			_enabledDependencies = [];			for(i = 0; i < len; ++i) {				dependency = _dependencies[i] as Dependency;				if(dependency.input.timerItem.sessionID == session) {					_enabledDependencies.push(dependency);				}			}		}	}}internal class SingletonEnforcer{}