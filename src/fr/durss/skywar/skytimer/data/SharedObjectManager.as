package fr.durss.skywar.skytimer.data {	import fr.durss.skywar.skytimer.events.SharedObjectManagerEvent;	import fr.durss.skywar.skytimer.graphics.sessionselector.vo.Session;	import fr.durss.skywar.skytimer.graphics.timers.item.TimerItem;	import fr.durss.skywar.skytimer.graphics.timers.window.contents.vo.Tag;	import fr.durss.skywar.skytimer.time.CustomTimer;	import fr.durss.skywar.skytimer.time.MainTimer;	import com.adobe.crypto.SHA1;	import flash.events.EventDispatcher;	import flash.geom.Point;	import flash.media.Sound;	import flash.net.SharedObject;	import flash.utils.Dictionary;	import flash.utils.describeType;	import flash.utils.getDefinitionByName;	/**	 * Manages all the data stored in SharedObjects.<br>	 * <br>	 * This class fires <code>SharedObjectManagerEvent</code> events.	 * 	 * @author Fran√ßois	 */	public class SharedObjectManager extends EventDispatcher {		public static var DEFAULT_SESSION:Session;		private static const VERSION:Number = .31;		private static const EXPORT_FILE_VERSION:Number = .1;		private static var _instance:SharedObjectManager;		private var _so:SharedObject;		private var _cache:Dictionary;		private var _currentSession:Session;						/* *********** *		 * CONSTRUCTOR *		 * *********** */		public function SharedObjectManager(enforcer:singletonEnforcer) {			if (enforcer == null) {				throw new Error("Error: Instantiation failed: Use SharedObjectManager.getInstance() instead of creating an instancenew.");			}			initialize();		}						/* ***************** *		 * GETTERS / SETTERS *		 * ***************** */		/**		 * Gets the static instance.<br>		 */		public static function getInstance():SharedObjectManager {			if (_instance == null) {				_instance = new SharedObjectManager(new singletonEnforcer());			}			return _instance;		}				/**		 * Gets if the internal clock should be used.		 */		public function get internalClock():Boolean { return getData("internalClock", false); }				/**		 * Sets if the internal clock should be used.		 */		public function set internalClock(value:Boolean):void { setData("internalClock", value); }						/**		 * Gets if the sound is muted.		 */		public function get soundMuted():Boolean { return getData("muteSound", false); }				/**		 * Sets if the sound is muted.		 */		public function set soundMuted(value:Boolean):void { setData("muteSound", value); }						/**		 * Gets if the window should be always on top.		 */		public function get alwaysInFront():Boolean { return getData("alwaysInFront", true); }				/**		 * Sets if the window should be always on top.		 */		public function set alwaysInFront(value:Boolean):void { setData("alwaysInFront", value); }						/**		 * Gets if the application should start at system startup.		 */		public function get startupExecute():Boolean { return getData("startupExecute", true); }				/**		 * Sets if the application should start at system startup.		 */		public function set startupExecute(value:Boolean):void { setData("startupExecute", value); }						/**		 * Gets if the system alerts are enabled (the window that popups at the bottom of the screen)		 */		public function get enableAlerts():Boolean { return getData("enableAlerts", false); }				/**		 * Sets if the system alerts are enabled (the window that popups at the bottom of the screen)		 */		public function set enableAlerts(value:Boolean):void { setData("enableAlerts", value); }						/**		 * Gets the cycle duration in milliseconds.		 */		public function get cycleDuration():Number { return getData("cycleDuration", 450000); }				/**		 * Sets the cycle duration in milliseconds.		 */		public function set cycleDuration(value:Number):void { setData("cycleDuration", value); }						/**		 * Gets the number of ethers won by cycles.		 */		public function get ethers():int { return getCurrentSession().ethers; }				/**		 * Sets the number of ethers won by cycles.		 */		public function set ethers(value:int):void {			var session:Session = getCurrentSession();			session.ethers = value;			saveSession(session);		}						/**		 * Gets the number of materials won by cycles.		 */		public function get materials():int { return getCurrentSession().materials; }				/**		 * Sets the number of materials won by cycles.		 */		public function set materials(value:int):void {			var session:Session = getCurrentSession();			session.materials = value;			saveSession(session);		}						/**		 * Gets if the first time input of the calculator should be filled with the result.		 */		public function get autoFillCalc():Boolean { return getData("autoFillCalc", true); }				/**		 * Sets if the first time input of the calculator should be filled with the result.		 */		public function set autoFillCalc(value:Boolean):void { setData("autoFillCalc", value); }						/**		 * Gets if the window should be only reduced to systray bar when close button is clicked.		 */		public function get systrayClose():Boolean { return getData("systrayClose", true); }				/**		 * Sets if the window should be only reduced to systray bar when close button is clicked.		 */		public function set systrayClose(value:Boolean):void { setData("systrayClose", value); }						/**		 * Gets the last window's position.		 */		public function get windowPos():Point {			var values:Array =  getData("windowPos", [-1, -1]);			return new Point(values[0], values[1]);		}				/**		 * Sets the last window's position.		 */		public function set windowPos(value:Point):void { setData("windowPos", [value.x, value.y]); }						/**		 * Gets the skin to display.<br>		 * <br>		 * To change the skin value use the <code>SkinMetrics</code> singleton!		 */		public function get skin():String { return getData("skin", SkinMetrics.SKIN_SKATCH); }				/**		 * Sets the skin to display.		 */		public function set skin(value:String):void { setData("skin", value); }						/**		 * Gets the timestamp reference for cycles (in milliseconds).		 */		public function get cycleTimeReference():Number { return getCurrentSession().cycle; }				/**		 * Sets the timestamp reference for cycles (in milliseconds).		 */		public function set cycleTimeReference(value:Number):void {			var session:Session = getCurrentSession();			session.cycle = value;			saveSession(session);		}						/**		 * Gets the current session ID to use.		 */		public function get currentSessionId():String { return getData("currentSession", DEFAULT_SESSION.id); }				/**		 * Sets the current session ID to use.		 */		public function set currentSessionId(value:String):void {			var i:int, len:int, change:Boolean, sessions:Array, session:Session;			change = (value != currentSessionId);			sessions	= getSessions();			len			= sessions.length;			for(i = 0; i < len; ++i) {				session = new Session(sessions[i]);				if(session.id == value) {					_currentSession = session;				}			}						if(_currentSession == null || value == DEFAULT_SESSION.id) {				_currentSession = DEFAULT_SESSION;			}						if(change) {				setData("currentSession", value);				dispatchEvent(new SharedObjectManagerEvent(SharedObjectManagerEvent.SESSION_CHANGE));			}		}						/**		 * Gets the current time (for internalClock mode only).		 */		public function get time():Number { return getData("time", 0); }				/**		 * Sets the current time (for internalClock mode only).		 */		public function set time(value:Number):void { setData("time", value); }						/**		 * Gets the user's GUID.		 */		public function get guid():String {			if(getData("guid", -1) == -1) {				var seed:Number = new Date().getTime() + Math.random();				setData("guid", SHA1.hash(seed.toString()));			}			return getData("guid", -1);		}						/* ****** *		 * PUBLIC *		 * ****** */		/**		 * Initializes the default session.<br>		 * <br>		 * This can't be done in the initialize method, where the most logical		 * place is, because of a stack overflow. Indeed, the Session class uses		 * the MaintTimer singleton to initialize itself, the MaintTimer uses the		 * SharedObjectManager singleton to initialize itself too. If both		 * singletons initialization have crossed references, then the _instance		 * var containing the singleton's instance hasn't got time to be ready		 * before the other singleton re-calls the getInstance() method.<br>		 * <br>		 * For exemple, if Singleton1 uses Singleton2 at init, and Singleton2		 * uses Singleton1. When Singleton1 is called the first time by calling		 * getInstance() method, it creates an _instance var like this :<br>		 * <code>_instance = new Singleton1();</code><br>		 * But, if during the construction, Singleton2 instance is created, if		 * this new singleton calls singleton1 directly in its init like this :<br>		 * <code>function Singleton2() {		 *    _myVar = Singleton1.getInstance().myProperty;		 * }</code><br>		 * then the _instance var of Singleton1 is not initialized yet. And so		 * the initialization is done another time. The same for Singleton2.		 * And that, infinitly which produce a stack overflow.		 */		public function createDefaultSession():void {			var defaultSession:Session = new Session(null, "#-defaultSession-#");			var i:int, len:int, exists:Boolean, sessions:Array;			sessions = getSessions();			len = sessions.length;			for(i = 0; i < len; ++i) {				if(new Session(sessions[i]).id == defaultSession.id) {					exists = true;					DEFAULT_SESSION = new Session(sessions[i]);					break;				}			}			if(!exists) {				DEFAULT_SESSION = defaultSession;				saveSession(defaultSession);			}		}				//__________________________________________________________ TIMERS				/**		 * Save the timers.<p>		 * 		 * @param <code>TimerItem</code>s collection.		 */		public function saveTimers(timers:Array):void {			var i:int, j:int, len:int, lenDep:int, depList:Array, obj:Object, timer:TimerItem, dependency:Dependency, save:Array, refs:Dictionary, indexes:Dictionary, colors:Dictionary;			save	= [];			refs	= new Dictionary();			colors	= new Dictionary();			indexes	= new Dictionary();			depList	= DependencyManager.getInstance().allDependencies;			len		= timers.length;			lenDep	= depList.length;						for(i = 0; i < len; ++i) {				timer	= timers[i] as TimerItem;				refs[timer] = i;			}						for(j = 0;j < lenDep; ++j) {				dependency = depList[j] as Dependency;				indexes[dependency.input.timerItem] = refs[dependency.output.timerItem];				colors[dependency.input.timerItem] = dependency.color;			}						for(i = 0; i < len; ++i) {				timer			= timers[i] as TimerItem;				obj				= timer.clock.soObject;				obj["v"]		= VERSION;				obj["name"]		= timer.name;				obj["color"]	= timer.color;				obj["sound"]	= String(describeType(timer.sound).@name).replace("::", ".");				obj["volume"]	= timer.volume;				obj["sessionID"]= timer.sessionID;				if(indexes[timer] != undefined) {					obj["output"]	= indexes[timer];//Stores the parent timer index.					obj["depColor"] = colors[timer];				}				save.push(obj);			}			setData("timers", save);		}		/**		 * Sets the timer's datas as anonymous object when loading from external files.		 */		public function setObjectTimers(data:Object):void {			if(data["v"] == undefined || data["v"] < EXPORT_FILE_VERSION) return;			var i:int, len:int, timers:Array, offset:int;						var sessions:Array = data["sessions"];			if(sessions != null) {				len = sessions.length;				for(i = 0; i < len; ++i) {					saveSession(new Session(sessions[i]));				}			}			timers = getData("timers", []);						//Change relations offset by the already existing timers.			len = data["timers"].length;			offset = timers.length;			for(i = 0; i < len; ++i) {				if(data["timers"][i]["output"] != undefined) {					data["timers"][i]["output"] += offset;				}			}						timers = timers.concat(data["timers"]);			setData("timers", timers);						internalClock = data["useInternalClock"];						if(internalClock) {				time = data["internalClockTime"];				MainTimer.getInstance().setTime(data["internalClockTime"]);			}						dispatchEvent(new SharedObjectManagerEvent(SharedObjectManagerEvent.TIMERS_UPDATE));			dispatchEvent(new SharedObjectManagerEvent(SharedObjectManagerEvent.SESSIONS_MODIFIED));		}		/**		 * Loads the timers from the Sharedobject.<p>		 * 		 * @return	<code>TimerItem</code>s collection.		 */		public function getTimers():Array {			var i:int, len:int, item:TimerItem, sound:Sound, ret:Array, save:Array, obj:Object, dependencies:Array, dependency:Dependency;			save	= getData("timers", []);			len		= save.length;			ret		= [];			dependencies = [];						for(i = 0; i < len; ++i) {				obj			= save[i];				if(obj["v"] < VERSION) continue;								item		= new TimerItem(obj["name"]);				item.color	= obj["color"];				try {					//Seems to be CPU consuming...					sound	= new (getDefinitionByName(obj["sound"]) as Class)() as Sound;				}catch(e:Error) { }				item.sound		= sound;				item.volume		= (obj["volume"] == undefined)? .5 : obj["volume"];				item.sessionID	= (obj["sessionID"] == undefined)? DEFAULT_SESSION.id : obj["sessionID"];				item.clock		= new CustomTimer(0, obj);				ret.push(item);			}						for(i = 0; i < len; ++i) {				obj		= save[i];				if(obj["output"] != undefined) {					dependency = new Dependency(TimerItem(ret[i]).plugger, TimerItem(ret[obj["output"]]).plugger, obj["depColor"]);					DependencyManager.getInstance().registerDependency(dependency, false);				}			}			return (ret == null)? [] : ret;		}				/**		 * Gets the timer's datas as anonymous object to save in external files.<br>		 * <br>		 * This object is then given to the <code>setObjectTimers</code> method.		 */		public function getObjectTimers():Object {			var ret:Object = {};			ret["v"] = EXPORT_FILE_VERSION;			ret["timers"] = getData("timers", []);			ret["sessions"] = getSessions();			ret["useInternalClock"] = internalClock;			ret["internalClockTime"]= MainTimer.getInstance().getTime();			return ret;		}												//__________________________________________________________ TAGS				/**		 * Gets the saved tags list.		 */		public function getTags():Array { return getData("tags", []); }				/**		 * Saves a tag.<p>		 * 		 * @param value		<code>TagVo</code> value object to register.		 * 		 * @return	if a tag has been overriden.		 */		public function saveTag(value:Tag):Boolean {			var i:int, len:int, tags:Array, exists:Boolean;			tags	= getTags();			len		= tags.length;			for(i = 0; i < len; ++i) {				if(new Tag(tags[i]).name == value.name){					tags[i]	= value.object;					exists	= true;					break;				}			}			if(!exists) {				tags.push(value.object);			}			setData("tags", tags);			_so.flush();			return exists;		}		/**		 * Deletes a saved tag.		 */		public function deleteTag(value:Tag):void {			var i:int, len:int, tags:Array;			tags	= getTags();			len		= tags.length;			for(i = 0; i < len; ++i) {				if(new Tag(tags[i]).name == value.name){					tags.splice(i, 1);					break;				}			}			setData("tags", tags);		}								//__________________________________________________________ SESSIONS				/**		 * Gets the sessions list.<br>		 * <br>		 * The returned array contains anonymous objects representing a session.<br>		 * This object can be passed as constructor parameter of the <code>Session</code>		 * class to initalize it.		 */		public function getSessions():Array { return getData("sessions", []); }				/**		 * Gets the currently selected session.		 * 		 * @return the current session object.		 */		public function getCurrentSession():Session {			if(_currentSession == null) {				//Seems stupid but it initializes the _currentSession var.				currentSessionId = currentSessionId;			}			return _currentSession;		}		/**		 * Saves a session.<br>		 * 		 * @param value		<code>Session</code> value object to register.		 * 		 * @return	if a session has been overriden.		 */		public function saveSession(value:Session):Boolean {			var i:int, len:int, sessions:Array, exists:Boolean;			sessions	= getSessions();			len			= sessions.length;			for(i = 0; i < len; ++i) {				if(new Session(sessions[i]).id == value.id){					sessions[i]	= value.object;					exists	= true;					break;				}			}			if(!exists) {				sessions.push(value.object);			}			setData("sessions", sessions);			return exists;		}		/**		 * Deletes a saved session.		 * 		 * @param id	session ID to destroy		 */		public function deleteSession(id:String):void {			var i:int, len:int, sessions:Array, timers:Array, timer:TimerItem, change:Boolean;			sessions	= getSessions();			len			= sessions.length;			for(i = 0; i < len; ++i) {				if(new Session(sessions[i]).id == id){					sessions.splice(i, 1);					break;				}			}						//Resets the session ID of the timers that were associated			//with the removed session.			timers = getTimers();			len = timers.length;			for(i = 0; i < len; ++i) {				timer = timers[i];				if(timer.sessionID == id) {					timer.sessionID = DEFAULT_SESSION.id;					change = true;				}				timers[i] = timer;			}			if(change) {				saveTimers(timers);				dispatchEvent(new SharedObjectManagerEvent(SharedObjectManagerEvent.TIMERS_UPDATE));			}			setData("sessions", sessions);		}								/* ******* *		 * PRIVATE *		 * ******* */		/**		 * Initializes some vars and the statics sharedObjects.<br>		 */		private function initialize():void {			_so		= SharedObject.getLocal("skytimer");			_cache	= new Dictionary();			delete _so.data["ethers"];			delete _so.data["materials"];			delete _so.data["cycleTimeReference"];		}		/**		 * Gets a SharedObject's data		 * 		 * @param id		datas ID.		 * @param value		data's value.		 */		private function setData(id:String, value:*):void {			_cache[id]		= value;			_so.data[id]	= value;						//Don't call flush() method! It kills the performances!			//Moreover the flush() method is automatically called on flash close			//and / or when the flash is garbage collected so it's not really needed.			//_so.flush();		}		/**		 * Gets a SharedObject's data.<p>		 * 		 * @param id			datas ID.		 * @param defaultValue	default value returned if the data does not exists yet.		 * 		 * @return	the data's value or the defaultValue parameter.		 */		private function getData(id:String, defaultValue:*):* {			if(_cache[id] == undefined) {				if(_so.data[id] == undefined) {					_so.data[id] = defaultValue;					_cache[id] = defaultValue;					return defaultValue;				}else{					_cache[id] = _so.data[id];				}			}			return _cache[id];		}	}}internal class singletonEnforcer { }